/*
   @Problem 2:（20 分）
   此題我們將實作一個簡單版的Maximum Bipartite Matching演算法。
   在這個題目中，我們將尋找一組一對一的配對方式來最大化總配對權重（weight）。
   這個演算法在實務上的應用有學校和學生的配對、公司和求職者的配對、捐腎者與受贈者的配對等等，以下我們將簡述此演算法。
   為了講解方便，我們假設有m個群組一的人與n個群組二的人要配對，任意兩個人配對在一起後都會產生一個配對權重（效益），而此權重已經被量化了。
   
   讓我們用以下表格來舉例：
   -----------------
   | 4 | 2 | 0 | 3 |
   |---------------|
   | 5 | 1 | 5 | 2 |
   |---------------|
   | 3 | 2 | 0 | 3 |
   -----------------
   在這個例子中，有3個人在群組一、4個人在群組2，任兩人配對的權重記錄在表格中，例如群組一的第2人和群組二的第4人配對的權重為2。
   
   由於要尋找一對一的配對，因此每一列最多只能對應到一欄，反之亦然。因此，以下的配對是不行的：
   -----------------
   | 4 |   |   |   |
   |---------------|
   | 5 |   | 5 |   |
   |---------------|
   |   |   |   |   |
   -----------------
   
   下方表格的配對情境皆為一對一的配對，因此是可行的，但在此題中並非最佳解，因為權重總和不夠大：
   -----------------
   | 4 |   |   |   |
   |---------------|
   |   |   |   | 2 |
   |---------------|
   |   |   | 2 |   |
   -----------------
   
   以下配對為此題的最佳解：
   -----------------
   | 4 |   |   |   |
   |---------------|
   |   |   | 5 |   |
   |---------------|
   |   |   |   | 3 |
   -----------------
   
   此題中我們將使用的方法如下。假設表格共有m列及n欄，且以i作為列的索引，j作為欄的索引。
   若m小於等於n，則從第一列開始往第m列做處理，針對第i列，去該列中找尋尚未被配對給任一列且能使wij最大的第j欄。如果有數欄都使wij最大，
   我們選編號j最小的將之稱為第j∗i欄，並將之配對給第i列。循此流程，我們將求得j∗_1、j∗_2直到 j∗_m，即為一組一對一的配對。
   這組配對的總配對權重即為∑_(i = 1)^m wi,j∗_i。

   若n小於m，則改由第一欄開始往第n欄做處理，針對第j欄，去該欄中找尋尚未被配對給任一欄且能使wij最大的第i列。如果有數列都使wij最大，
   我們選編號i最小的將之稱為第i∗j列，並將之配對給第j欄。循此流程，我們將求得i∗_1、i∗_2直到 i∗_n，即為一組一對一的配對。
   這組配對的總配對權重即為∑_(i = 1)^n wi∗_j,j。
   
   以前述3 × 4的表格為例，因為m = 3 < n = 4，因此我們以列為單位看。
   第一列中，由於沒有其他欄的值大於4（在第一欄），因此j∗_1 = 1。
   接下來看第二列，由於第一欄已經被使用過了，因此我們選擇這一列中除了第一欄外最大的值（在第三欄），j∗_2 = 3。
   最後看第三列，撇除第一欄及第三欄外最大的值為第四欄，因此j∗_3=4。將總權重加起來，總共為4 + 5 + 3 = 12，即為這組配對的總配對權重。
   
   在本題中，請使用本題指定的演算法，針對給定的輸入求得一組配對，並計算其總配對權重。
*/

/*
   @Input：
   系統會提供一共10組測試資料，每組測試資料裝在一個檔案裡。
   在每個檔案中，總共有m + 1行。第一行有2個正整數，分別為m、n，分別代表列數及欄數。
   第二行至第m + 1行之中，第i + 1行有n個整數wi,1到win，任意兩個整數之間以空白隔開。
   已知1≤m≤100、1≤n≤100、0≤wmn≤100。
*/

/*
   @Output：
   讀入這些數字之後，請依上述規則，
   當m ≤ n時，輸出j∗_1、j∗_2到j∗_n，任兩個整數之間以逗號隔開，最後再輸出一個分號後輸出總配對權重。
   當n < m時，輸出i∗_1、i∗_2到i∗_n，任兩個整數之間以逗號隔開，最後再輸出一個分號後輸出總配對權重。
*/

/*
   @Sample Input：
   #sample 1
   3 4
   4 2 0 3
   5 1 5 2
   3 0 2 3
   #sample 2
   3 4
   5 1 5 2
   4 2 0 3
   3 0 2 3
   #sample 3
   4 3
   5 1 5
   4 2 0
   3 0 2
   6 1 3
   
   @Sample Output：
   #sample 1: 1,3,4;12
   #sample 2: 1,4,3;10
   #sample 3: 4,2,1;13
*/

#include <iostream>
#include <vector>
using namespace std;

vector<vector<int> > transpose(vector<vector<int> > &matrix)
{

    vector<vector<int>> v(matrix[0].size(),vector<int>());
    for(int i = 0; i < matrix.size(); i++)
    {
        for (int j = 0; j < matrix[0].size(); j++)
        {
            v[j].push_back(matrix[i][j]);
        }
    }

    return v;

}

int main()
{
    int m=0;
    int n=0;
    cin >> m >> n;

    vector<vector<int>> contents;

    for (int i = 0; i < m; ++i) {
        vector<int> vi;
        for (int j = 0; j < n; ++j){
            int val;
            cin >> val;
            vi.push_back(val);
        }
        contents.push_back(vi);

    }

    if(m>n){
        contents = transpose(contents);
        int tmp = m;
        m = n;
        n = tmp;
    }

//    cout << "\nThe numbers are" << endl;
//    for (int i = 0; i < m; ++i) {
//        for (int j = 0; j < n; ++j){
//            cout << contents[i][j] << " ";
//        }
//        cout << endl;
//    }


    vector<int> indexes;
    int weights=0;
    int a[n];
    for(int i=0; i<n; ++i) a[i]=0;

    for (int i = 0; i < m; ++i) {
        int max=0;
        int index=0;
        for (int j = 0; j < n; ++j){
            if (a[j] == 0 and contents[i][j] > max) {
                max = contents[i][j];
                index = j;
            }

        }
        a[index] = 1;
        weights += max;
        indexes.push_back(index);
    }

    int i = 0;
    for(auto j: indexes){
        cout << j+1;

        if(i == indexes.size()-1)
            cout << ";";
        else cout << ',';
        i++;
    }
    cout << weights;
    

    return 0;
}